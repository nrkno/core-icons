const fs = require("fs")
const path = require("path")
const process = require("process")
const svg2vectordrawable = require('svg2vectordrawable/src/svg-file-to-vectordrawable-file')

const CORE_ICON_DIRECTORIES = [
    "lib/expressive",
    "lib/icon",
    // TODO are these needed? Especially preview?
    //  There's also a directory called lib/logo/large which has to be handled somehow now
    //"lib/logo",
    //"lib/preview"
]
const ANDROID_DRAWABLE_FOLDER = "android/icons/src/main/res/drawable"
const ANDROID_ICONS_FOLDER = "android/icons/src/main/kotlin/no/nrk/core/icons"

const svg2vectordrawableOptions = {
    floatPrecision: 4,
    strict: false,
    // TODO some icons just have no color now. setting fillBlack true at least makes them black, but we probably want #FFF0F0F0 instead
    // Docs say that you can do "tint: '#FFF0F0F0" but that doesn't seem to do anything
    // The SVGs have "fill=currentColor", and the library has this check if (!/^url\(#.*\)$/.test(elem.attr('fill').value))
    // I think if the SVGs have an actual hex color here it will work
    // Otherwise we might have to manually loop over the generated files and override the color, which is a bit stupid
    fillBlack: true,
    xmlTag: false
}

async function app(github, context, exec) {
    convertSvgToXml()
}

async function convertSvgToXml() {
    sanitizeDir(ANDROID_DRAWABLE_FOLDER)
    sanitizeDir(ANDROID_ICONS_FOLDER)

    var allFiles = []
    var hasErrors = false
    for (const directory of CORE_ICON_DIRECTORIES) {
        const files = fs.readdirSync(directory)

        for (const file of files) {
            const xmlFileName = file.replace(".svg", ".xml").replaceAll("-", "_").toLowerCase()
            if (!/^([a-z0-9\_])+\.xml$/.test(xmlFileName)) {
                console.error(`Invalid file name: "${file}"! (output xml name: "${xmlFileName})`)
                hasErrors = true

                continue
            }

            if (allFiles.includes(xmlFileName)) {
                console.error(`Found duplicate file name: "${file}"`)
                hasErrors = true

                continue
            }

            allFiles.push(xmlFileName)

            const svgFile = path.join(directory, file)
            const xmlFile = path.join(ANDROID_DRAWABLE_FOLDER, xmlFileName)

            await svg2vectordrawable.convertFile(svgFile, xmlFile, svg2vectordrawableOptions)
        }
    }

    if (hasErrors) {
        process.exit(1)
    }

    generateKotlinValues()
}

function generateKotlinValues() {
    // Read the files generated above and look for those that have "_expressive" in them and generate Kotlin values from them
    // This assumes that an icon called "horse_expressive.xml" will always have a counterpart named "horse.xml"
    const generatedDrawables = fs.readdirSync(ANDROID_DRAWABLE_FOLDER)

    const lines = []
    lines.push("package no.nrk.core.icons")

    lines.push("")
    lines.push("import androidx.compose.runtime.Composable")
    lines.push("import androidx.compose.runtime.staticCompositionLocalOf")
    lines.push("import androidx.compose.ui.graphics.painter.Painter")
    lines.push("import androidx.compose.ui.res.painterResource")

    lines.push("")
    lines.push("// Warning: This is an autogenerated file. Please do not edit it manually")
    lines.push("")

    // It's unlikely that this will change on most screens, so it's probably a bit more efficient to use staticCompositionLocalOf here, right?
    lines.push("val LocalUseExpressiveIcons = staticCompositionLocalOf<Boolean> {")
    lines.push("\terror(\"LocalUseExpressiveIcons not found\")")
    lines.push("}")
    lines.push("")

    lines.push("data class NrkIcon(")
    lines.push("\tval normal: Int,")
    lines.push("\tval expressive: Int?")
    lines.push(") {")
    lines.push("\t@Composable")
    lines.push("\tfun asPainter(): Painter {")
    lines.push("\t\treturn painterResource(")
    lines.push("\t\t\tid = if (LocalUseExpressiveIcons.current) {")
    lines.push("\t\t\t\texpressive ?: normal")
    lines.push("\t\t\t} else {")
    lines.push("\t\t\t\tnormal")
    lines.push("\t\t\t}")
    lines.push("\t\t)")
    lines.push("\t}")
    lines.push("}")
    lines.push("")

    lines.push("object NrkIcons {")

    for (const drawable of generatedDrawables) {
        const isExpressive = drawable.match("_expressive")

        // Expressive variants are added along with the normal ones
        if (isExpressive) {
            continue
        }

        const rawNormalIconName = drawable.replace(".xml", "")

        const normalR = "R.drawable." + rawNormalIconName
        let expressiveR = null

        // Probably a more efficient way to do this, but I don't think it really matters
        const expressiveVariant = generatedDrawables.find((element) => element == rawNormalIconName + "_expressive.xml")

        if (expressiveVariant != null) {
            expressiveR = "R.drawable." + expressiveVariant.replace(".xml", "")
        }

        lines.push("\tval " + convertFromSnakeOrKebabCaseToPascalCase(rawNormalIconName) + " = NrkIcon(")
        lines.push("\t\tnormal = " + normalR + ",")
        lines.push("\t\texpressive = " + expressiveR)
        lines.push("\t)")
        lines.push("")
    }

    // Remove the last newline
    lines.pop()

    // End the object
    lines.push("}")

    const stream = fs.createWriteStream(ANDROID_ICONS_FOLDER + "/NrkIcons.kt", { flags: 'a' });
    for (const line of lines) {
        stream.write(`${line}\n`);
    }
    stream.end();
}

function convertFromSnakeOrKebabCaseToPascalCase(string) {
    return string.split(/[-_]/).map((s) => s.charAt(0).toUpperCase() + s.substring(1)).join('');
}

function sanitizeDir(directory) {
    const generatedDir = path.resolve(directory);
    if (fs.existsSync(generatedDir)) {
        fs.rmSync(generatedDir, { recursive: true });
    }
    fs.mkdirSync(generatedDir, { recurisve: true });
}

module.exports = async (github, context, exec) => {
    return app(github, context, exec)
}

// If script is called directly https://stackoverflow.com/a/6398335
if (require.main === module) {
    convertSvgToXml()
}
